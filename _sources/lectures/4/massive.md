# Массивы и указатели

(massiv_and_points)=

## Напоминание из СИ

В текущем занятии используется класс `CPoint`:

```{toggle}
    class CPoint 
    { // описание класса “точка”
        public:
            int x, y; // координаты точки

            CPoint( int newX=0, int newY=0 ) // конструктор
            { 
                Set(newX,newY); 
            } 

            ~CPoint() // деструктор
            { 
                cout << "Я уничтожил: " << x << " " << y << endl; 
            } 

            void Set( int newX=0, int newY=0 ) // установка значений
            { 
                x=newX, y=newY; 
            } 

            void Set_from_console() // установка значений
            { 
                cout << "Enter x: ";
                cin >> x;
                cout << endl << "Enter y: ";
                cin >> y;
                cout << endl;
            } 
    };
```

Объявление статического массива:

```cpp
//<тип данных> <название переменной для массива>[<константное целое число>]
// Пример:
    const int N=12;     
    CPoint PtArray[N];
```

```{Important}
Стоит хорошо запомнить: Имя переменной для массива --- является указателем на первый элемент массива.
```

Напоминаю объявление указателя:

```cpp
// <тип данных> * <название переменной для указателя>
// Пример:
    CPoint * pPoint;
```

Теперь у нас есть два указателя на тип данных `CPoint`. Но пока что `pPoint` не указывает ни на что, он только объявлен. Чтобы инициализировать его надо написать следующее:

```cpp
    pPoint = PtArray;       // pPoint указывает на первый элемент массива
    pPoint = &PtArray[5];   // pPoint указывает на пятый элемент массива
    pPoint = PtArray + 10;  // pPoint указывает на десятый элемент массива
```

```{note}
Операция:
`PtArray[5]` --- аналогична операции: `*(PtArray + 5)`
```

## Нововведение в СИ++ оператор `->`

Если указатель указывает на класс или структуру, то по нему можно получить поля(атрибуты) или выполнить вызов метода обычным способом:

```cpp
    cout << (*pPoint).x; // при условии что x --- в публичной части класса
    (*pPoint).Set(2, 2);
```

В Си++ введен оператор обращения к классу `->`. Действие этого оператора полностью аналогично операциям выше, но выглядит более изящно:

```cpp
    cout << pPoint->x; // при условии что x --- в публичной части класса
    pPoint->Set(2, 2);
```
